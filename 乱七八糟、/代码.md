**// ! 手写promise.all**

```
  function promiseAll(promises) {
        return new Promise(function (resolve, reject) {
            if (!Array.isArray(promises)) {
                return reject(new TypeError('argument must be a array'));
            }
        })
        var resolveCounter = 0;
        var promiseNum = promises.length;
        var resolvedValues = new Array(promiseNum);
        for (let i = 0; i < promiseNum; i++) {
            (function (i) {
                Promise.resolve(promises[i]).then(function (value) {
                    resolveCounter++;
                    resolvedValues[i] = value;
                    if (resolveCounter == promiseNum) {
                        return resolve(resolvedValues)
                    }
                }, function (reason) {
                    return reject(reason);
                })
            })(i)

        }
    }
    let a = Promise.resolve(1)
    let b = Promise.reject(2)
    let c = Promise.resolve(3)

    promiseAll([a, b, c])
```



**// ! 实现原生ajax请求**
/*

const ajax = {
    get(url, fn) {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url, true)   //第三个参数表示异步与否
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                fn(xhr.responseText)
            }
        }
        xhr.send()
        xhr.onload = function () {
            console.log('服务器返回数据了');
        }
    },
    post(url, data, fn) {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', url, true);
        // 添加http头，发送信息之服务器时内容编码类型
        xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        // data应为'a = a1 & b =b1'这种字符串格式，在jquery里 如果data为对象，会自动将对象转换成这种字符串格式
        xhr.send(data)
        // onreadystatechange：每当readystate改变的时候，onreadystatechange函数就会被执行
        // xhr.readystate === 4 表示状态为complate
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
                fn(xhr.responseText)
            }
        }
        xhr.onload = function () {
            console.log(xhr.response);
        }
    }
}
*/
**// !封装自己的ajax 未完成**
/*
function myAjax(opt) {
    let xhr = new XMLHttpRequest();
    // 构造查询参数 并拼接在地址上
    if (opt.params) {
        //
        let obj = opt.params;
        let ary = [];
        for (key in obj) {
            ary.push(key + '=' + obj[key]);
        }
        let url_str = ary.join('&');
        xhr.open(opt.method.opt.url + '?' + url_str);
    } else {
        xhr.open(opt.method, opt.url);
    }
    // console.log('hello world!');
}
*/
// ! 手写new的过程
/*

function myNew(fn, ...args) {
    const obj = {};
    obj.__proto__ = fn.prototype;
    fn.apply(obj, args);
    return obj
}
*/
// !instanceof关键字
/*
function instanceOf(father, child) {
    const fp = father.prototype
    var cp = child.__proto__
    while (cp) {
        if (cp === fp) {
            return true
        }
        cp = cp.__proto__;
    }
    return false
}
*/
// ! 实现防抖函数
/*
function debounce(fn, delay = 500) {
    let timer;
    return function () {
        if (timer) {
            clearInterval(timer);
        }
        const args = arguments;
        timer = setInterval(() => {
            fn.apply(this, args)  //改变this指向为调用debounce的对象
        }, delay)
    }
}
*/
// !实现节流函数
/*
function throttle(fn, delay = 200) {
    let flag = true;
    return function () {
        if (flag) return
        flag = false
        const args = arguments;
        setInterval(() => {
            fn.apply(this, args)
            flag = true
        }, delay)
    }
}
*/
// !实现数组去重
/*
// 第一种 Map记录
function quchong1(arr) {
    const newArr = [];
    arr.reduce((pre, next) => {
        if (!pre.has(next)) {
            pre.set(next, 1)
            newArr.push(next);
        }
        return pre
    }, new Map())
    return newArr
}

// 第二种 set去重
function quchong2(arr) {
    return [...new Set(arr)]
}
*/
// ! 用setTimeout实现setInterval
/*
function mySetTimeout(fn, delay) {
    let timer = null;
    const interval = () => {
        fn();
        timer = setTimeout(interval, delay)
    }
    setTimeout(interval, delay)
    return {
        cancel: () => {
            clearTimeout(timer)
        }
    }
}

// 测试
const { cancel } = mySetInterval(() => console.log('123'), 1000)
setTimeout(() => { cancel() }, 4000)
*/
// ! 用setInterval实现setTimeout
/*
function mySetInterval(fn, delay) {
    const timer = setInterval(() => {
        fn()
        clearInterval(timer)
    }, delay)
}

// 测试

mySetInterval(() => { console.log('123') }, 1000)
*/
// ! 实现一个compose函数
/*
function fn1(x) {
    return x + 1;
}
function fn2(x) {
    return x + 2;
}
function fn3(x) {
    return x + 3;
}
function fn4(x) {
    return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4);
console.log(a);
console.log(a(1));

function compose(...fn) {
    if (fn.length === 0) return (num) => num;
    if (fn.length === 1) return fn[0]
    return fn.reduce((pre, next) => {
        return (num) => {
            return next(pre(num))
        }
    })
}
*/

// !实现一个柯里化函数
/*
function currying(fn, ...args1) {
    // 获取fn参数有几个
    const length = fn.length
    let allArgs = [...args2]
    const res = (...args2) => {
        allArgs = [...allArgs, ...args2]
        // 长度相等就返回执行结果
        if (allArgs.length === length) {
            return fn(...allArgs)
        } else {
            // 不相等返回函数
            return res
        }
    }
    return res
}
// 测试
const add = (a,b,c) =>{a+b+c};
const a = currying(add,1);
console.log(a(2,3));
*/

// !实现一个LRU缓存函数
/*
class LRUCache {
    constructor(size) {
        this.size = size;
        this.cache = new Map()
    }
    get(key) {
        const hasKey = this.cache.has(key)
        if (hasKey) {
            const val = this.cache.get(key);
            this.cache.delete(key)
            this.cache.set(key, val)
            return val
        } else {
            return -1
        }
    }
    put(key, val) {
        const hasKey = this.cache.has(key)
        if (hasKey) {
            this.cache.delete(key)
        }
        this.cache.set(key, val)
        if (this.cache.size > this.size) {
            this.cache.delete(this.cache.keys().next().value)
        }
    }
}
*/
// ! 实现简单 发布订阅模式
/*
class EventEmitter {
    constructor() {
        this.cache = []
    }
    on(name, fn) {
        const tasks = this.cache[name];
        if (tasks) {
            this.cache[name].push(fn)
        } else {
            this.cache[name] = [fn]
        }
    }
    off(name, fn) {
        const tasks = this.cache[name];
        if (tasks) {
            const index = tasks.findIndex(item => item === fn)
            if (index >= 0) {
                this.cache[name].splice(index, 1)
            }
        }
    }
    emit(name, ...args) {
        // 复制一份，防止回调里继续on，导致死循环
        const tasks = this.cache[name].slice()
        if (tasks) {
            for (let fn of tasks) {
                fn(...args)
            }
        }
    }
    once(name, cb) {
        function fn(...args) {
            cb(args)
            this.off(name, fn)

        }
        this.on(name, fn)
    }
}
*/

// ! 实现JSON.prase
/*
function parse(json) {
    return eval("(" + json + ")")
}
*/
// !将DOM转化成树形结构对象
/*
<div>
    <span></span>
    <ul>
        <li></li>
        <li></li>
    </ul>
</div>

*/
/*
function domTree(dom) {
    const obj = {}
    obj.tag = dom.tagName
    obj.children = []
    dom.childNodes.foreach((child) => { obj.children.push(domTree(child)) })
    return obj
}
*/
// ! 将树结构转换为DOM
/*
// 真正的渲染函数
function _reader(vnode) {
    // 如果是数字类型转化为字符串
    if (typeof vnode === "number") {
        vnode = String(vnode);

    }
    // 字符串类型直接就是文本节点
    if (typeof vnode === "string") {
        return document.createTextNode(vnode);
    }
    // 普通DOM
    const dom = document.createElement(vcode.tag);
    if (vcode.attrs) {
        // 遍历属性
        Object.keys(vnode.attrs).forEach((key) => {
            const value = vnode.attrs[key];
            dom.setAttribute(key, value);
    
        })
    }
    // 子数组进行递归
    vnode.children.forEach((child) => { dom.appendChinld(_reader(child)) })
    return dom
}
*/
// !判断一个对象有环引用
/*
function cycleDetector(obj) {
    const arr = [obj]
    let flag = false;
    function cycle(o) {
        const keys = Object.keys(o)
        for (const key of keys) {
            const temp = o[key]
            if (typeof temp === 'object' && temp !== null) {
                if (arr.indexOf(temp) >= 0) {
                    flag = true;
                    return
                }
                arr.push(temp)
                cycle(temp)
            }
        }
    }
    cycle(obj)
    return flag
}
*/
// !计算一个对象的层数
/*
function loopGetLevel(obj) {
    var res = 1;
    function computedLevel(obj, level) {
        var level = level ? level : 0;
        if (typeof obj === 'object') {
            for (var key in obj) {
                if (typeof obj[key] === 'object') {
                    computedLevel(obj[key], level + 1);
                } else {
                    res = level + 1 > res ? level + 1 : res;
                }
            }
        } else {
            res = level > res ? level : res
        }
    }
    computedLevel(obj)
    return res
}
*/
// ! 对象的扁平化
/*
const isObject = (val) => typeof val === 'object' && val !== null
function flatten(obj) {
    if (!isObject(obj)) return
    const res = {}
    const dfs = (cur, prefix) => {
        if (isObject(cur)) {
            if (Array.isArray(cur)) {
                cur.forEach((item, index) => {
                    dfs(item, `${prefix}[${index}]`)
                })
            } else {
                for (let key in cur) {
                    dfs(cur[key], `${prefix}${prefix ? '.' : ''}${key}`)
                }
            }

        } else {
            res[prefix] = cur
        }
    }
    dfs(obj, '')
    return res
}

// 测试
console.log(flatten(obj));

*/
// !实现（a==1&&a==2&&a==3）为true
/*
// 第一种
var a = {
    i: 1,
    toString: function () {
        return a.i++
    }
}
console.log(a == 1 && a == 2 && a == 3);
// 第二种
var a = [1, 2, 3];
a.join = a.shift;
console.log(a == 1 && a == 2 && a == 3);
// 第三种
var val = 0;
Object.defineProperty(window, 'a', {
    get: function () {
        return ++val;
    }
})
console.log(a == 1 && a == 2 && a == 3);
*/
// !实现限制并发的Promise调度器
/*
class Scheduler {
    constructor(limit) {
        this.queue = []
        this.limit = limit
        this.count = 0
    }
    add(time, order) {
        const promiseCreator = () => {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    console.log(order);
                    resolve()

                }, time)
            })
        }
        this.queue.push(promiseCreator)
    }
    taskStart() {
        for (let i = 0; i < this.limit; i++) {
            this.request()
        }
    }
    request() {
        if (!this.queue.length || this.count >= this.limit) return
        this.count++
        this.queue.shift()().then(() => {
            this.count++
            this.request()
        })
    }
}
// 测试
const scheduler = new Scheduler(2);
const addTask = (time, order) => {
    scheduler.add(time, order)
}
addTask(1000, "1")
addTask(500, "2")
addTask(300, "3")
addTask(400, "4")
scheduler.taskStart()
*/

// !实现lazyman函数
/*
class _lazyMan {
    constructor(name) {
        this.tasks = []
        const task = () => {
            console.log(`hello this is ${name}`);
            this.next()
        }
        this.tasks.push(task)
        setTimeout(() => {
            this.next()
        }, 0)
    }
    next() {
        const task = this.tasks.shift()
        task && task()
    }
    sleep(time) {
        this.sleepWrapper(time, false)
        return this
    }
    sleepFirst(time) {
        this.sleepWrapper(time, true)
        return this
    }
    sleepWrapper(time, first) {
        const task = () => {
            setTimeout(() => {
                console.log(`wake up after ${time}`);
                this.next()
            }, time * 1000)
        }
        if (first) {
            this.tasks.unshift(task)
        } else {
            this.task.push(task)
        }
    }
    eat(food) {
        const task = () => {
            console.log(`eat ${food}`);
            this.next()
        }
        this.tasks.push(task);
        return this
    }
}
// 测试
const lazyMan = (name) => new _lazyMan(name)
lazyMan('mzh').sleep(1).eat('dinner')
lazyMan('mzh').eat('dinner').eat('rice')
lazyMan('mzh').eat('rice').sleepFirst(5)
*/
// !实现add函数
/*
function add(...args1) {
    let allArgs = [...args1]
    function fn(...args2) {
        if (!args2.length) return fn.toString()
        allArgs = [...allArgs, ...args2]
        return fn
    }
    fn.toString = function () {
        return allArgs.reduce((pre, next) => {
            pre = next
        })
    }
    return fn;
}
// 测试
console.log(add(1)(2)(3)());
console.log(add(1, 2), add(3)());
*/
// !实现async/await
/*
async function asyncFn() {
    const num1 = await fn(1)
    console.log(num1);
    const num2 = await fn(num1);
    console.log(num2);
    const num3 = await fn(num2);
    console.log(num3);
    return num3
}
const asyncRes = asyncFn()
console.log(asyncRes);
asyncRes.then(res => console.log(res))
*/

// !实现一个合格的深拷贝
/*
function deepClone(target, map = new Map()) {
    // 基本数据类型直接返回
    if (typeof target !== 'object') {
        return target
    }

    // 引用数据类型特殊处理 判断是数组还是对象
    const temp = Array.isArray(target) ? [] : {}
    if (map.get(target)) {
        // 已存在则直接返回
        return map.get(target)
    }
    // 不存在则第一次设置
    map.set(target, temp)
    for (const key in target) {
        //  递归
        temp[key] = deepClone(target[key], map)
    }
    return temp
}
const a = {
    name: 'mzh',
    age: 18,
    hobies: {
        sport: {
            island: ['basketball', 'sing', 'jump', 'RAP'],
            water: ['swim', 'row boat']
        },
        food: 'noodles'
    },
    works: ['2021', '2022']
}
// a.key = a // 环引用
const b = deepClone(a)
console.log(b);
*/

// ! foreach
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '36' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '36' },
]
Array.prototype.mzh_forEach = function (callback) {
    for (let i = 0; i < this.length; i++) {
        callback(this[i], i, this)
    }
}
players.mzh_forEach(function (item, index, arr) {
    console.log(item, index);
}, players)
*/

// ! map
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_map = function (callback) {
    const res = []
    for (let i = 0; i < this.length; i++) {
        res.push(callback(this[i], i, this))
    }
    return res
}
console.log(players.mzh_map((item, index) => `${item.name}--${index}`));
*/

// !filter
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_filter = function (callback) {
    const res = []
    for (let i = 0; i < this.length; i++) {
        callback(this[i], i, this) && res.push(this[i])
    }
    return res
}
console.log(players.mzh_filter(item => item.age >= 35));
*/

// !every
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_every = function (callback) {
    let flag = true;
    for (let i = 0; i < this.length; i++) {
        flag = callback(this[i], i, this)
        if (!flag) break
    }
    return flag
}
console.log(players.mzh_every(item => item.age >= 30));
console.log(players.mzh_every(item => item.age >= 18));
*/

// !some
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_some = function (callback) {
    let flag = false
    for (let i = 0; i < this.length; i++) {
        flag = callback(this[i], i, this)
        if (flag) break
    }
    return flag
}
console.log(players.mzh_some(item => item.age >= 30));
console.log(players.mzh_some(item => item.age >= 50));
*/

// !reduce
/*
const players = [
    { name: 'kobe', age: 36 },
    { name: 'curry', age: 30 },
    { name: 'durant', age: 36 },
    { name: 'james', age: 18 },
]
Array.prototype.mzh_reduce = function (callback, ...args) {
    let start = 0, pre
    if (args.length) {
        pre = args[0]
    } else {
        pre = this[0]
        start = 1;

    }
    for (let i = start; i < this.length; i++) {
        pre = callback(pre, this[i], i, this)
    }
    return pre
}
// 计算所有num相加
const sum = players.mzh_reduce((pre, next) => {
    return pre + next.age
}, 0)
console.log(sum);
*/

// !findindex
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_findIndex = function (callback) {
    for (let i = 0; i < this.length; i++) {
        if (callback(this[i], i, this)) {
            return i
        }
    }
    return -1
}
console.log(players.mzh_findIndex(item => item.name === 'kobe'));
console.log(players.mzh_findIndex(item => item.name === 'mzh'));
*/

// !find
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_find = function (callback) {
    for (let i = 0; i < this.length; i++) {
        if (callback(this[i], i, this)) {
            return this[i]
        }
    }
    return undefined
}
console.log(players.mzh_find(item => item.name === 'kobe'));
console.log(players.mzh_find(item => item.name === 'mzh'));
*/

// !fill
/*
const players = [
    { name: 'kobe', age: '36' },
    { name: 'curry', age: '30' },
    { name: 'durant', age: '36' },
    { name: 'james', age: '18' },
]
Array.prototype.mzh_fill = function (value, start = 0, end) {
    end = end || this.length
    for (let i = start; i < end; i++) {
        this[i] = value
    }
    return this
}
console.log(players.mzh_fill('马中豪', 1, 3));
*/

// !includes
/*
Array.prototype.mzh_includes = function (value, start = 0) {
    if (start < 0) start = this.length = start
    const isNaN = Number.isNaN(value)
    for (let i = start; i < this.length; i++) {
        if (this[i] === value || (isNaN && Number.isNaN(this[i]))) {
            return true
        }
    }
    return false
}
console.log([1, 2, 3].mzh_includes(2));
console.log([1, 2, 3, NaN].mzh_includes(NaN));
console.log([1, 2, 3].mzh_includes(4));
*/

// !join
/*
Array.prototype.mzh_join = function (s = ',') {
    let str = ''
    for (let i = 0; i < this.length; i++) {
        str = i === 0 ? `${str}${this[i]}` : `${str}${s}${this[i]}`
    }
    return str
}
console.log([1, 2, 3].mzh_join());
console.log([1, 2, 3].mzh_join('?'));
*/

// !flat
/*
Array.prototype.mzh_flat = function (num = Infinity) {
    let arr = this;
    let i = 0;
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
        i++
        if (i >= num) break
    }
    return arr
}
const testArr = [1, [2, 3, [4, 5]], [8, 9]]
console.log(testArr.mzh_flat());
*/

// !splice
/*
Array.prototype.mzh_splice = function (start, length, ...values) {
    if (length === 0) return []
    length = start + length > this.length - 1 ? this.length - start : length
    const res = [], tempArr = [...this]
    for (let i = start; i < start + values.length; i++) {
        this[i] = values[i - start]
    }
    this.length = start + values.length
    if (values.length < length) {
        const cha = length - values.length
        for (let i = start + values.length; i < tempArr.length; i++) {
            this[i] = tempArr[i + cha]
        }
        this.length = this.length - cha
    }
    if (values.length > length) {
        for (let i = start + length; i < tempArr.length; i++) {
            this.push(tempArr[i])
        }

    }
    for (let i = start; i < start + length; i++) {
        res.push(tempArr[i])
    }
    return res
}
let arr = [1, 2, 3, 4, 5]

console.log(arr.mzh_splice(2, 2, [9, 9, 8, 7]));
console.log(arr);
*/

// ! entries
/*
const obj = {
    name: '马中豪',
    age: 18,
    gender: '男'
}
Object.prototype.mzh_entries = function (obj) {
    const res = []
    for (let key in obj) {
        obj.hasOwnProperty(key) && res.push([key, obj[key]])
    }
    return res
}
console.log(Object.mzh_entries(obj));
*/

// !fromEntries
/*
Object.prototype.mzh_fromEntries = function (arr) {
    const obj = {}
    for (let i = 0; i < arr.length; i++) {
        const [key, value] = arr[i]
        obj[key] = value
    }
    return obj
}
console.log(Object.mzh_fromEntries([['name', '马中豪'], ['age', 18], ['gender', '男']]));
*/

// !keys
/*
const obj = {
    name: '马中豪',
    age: 18,
    gender: '男'
}
Object.prototype.mzh_keys = function (obj) {
    const keys = []
    for (let key in obj) {
        obj.hasOwnProperty(key) && keys.push(key)
    }
    return keys
}
console.log(Object.mzh_keys(obj));
*/
// !values
/*
Object.prototype.mzh_values = function (obj) {
    const values = []
    for (let key in obj) {
        obj.hasOwnProperty(key) && values.push(obj[key])
    }
    return values
}
console.log(Object.mzh_values(obj));
*/

// !instanceOf  用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上
/*
function instanceOf(father, child) {
    const fp = father.prototype
    var cp = child.__proto__
    while (cp) {
        if (cp === fp) {
            return true
        }
        cp = cp.__proto__
    }
    return false
}
function Person(name) {
    this.name = name
}
const mzh = new Person('马中豪')
const mzh1 = { name: '马中豪' }
console.log(instanceOf(Person, mzh));
console.log(instanceOf(Person, mzh1));
*/

// !is  判断是否相等、
/*
Object.prototype.mzh_is = function (x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y
    }
    return x !== x && y !== y
}
const a = { name: 'mzh' }
const b = a
const c = { name: 'mzh' }
console.log(Object.mzh_is(a, b));
console.log(Object.mzh_is(a, c));
*/

// !assign  实现对象的合并
/*
Object.prototype.mzh_assign = function (target, ...args) {
    if (target === null || target === undefined) {
        throw new TypeError('cannot convert undefined or null to object')
    }
    target = Object(target)
    for (let nextObj of args) {
        for (let key in nextObj) {
            nextObj.hasOwnProperty(key) && (target[key] = nextObj[key])
        }
    }
    return target
}
const testa = { name: 'mzh' }
const testb = { name: 'mzh', age: 18 }
const testc = { age: 19, gender: '男' }
const testd = Object.mzh_assign(testa, testb, testc)
console.log(testd);
console.log(testa === testd);
*/

// !call  改变this指向
/*
Function.prototype.mzh_call = function (obj, ...args) {
    obj = obj || window
    // Symbol 是唯一的  防止重名key
    const fn = Symbol()
    obj[fn] = this
    return obj[fn](...args)
}
const testobj = {
    name: 'mzh',
    testFn(age) {
        console.log(`${this.name}已经${age}岁`);
    }
}
const testobj2 = {
    name: '2mzh'
}
testobj.testFn.mzh_call(testobj2, 22)
*/

// !apply
/*
Function.prototype.mzh_apply = function (obj, args) {
    obj = obj || window
    const fn = Symbol();
    obj[fn] = this

    return obj[fn](...args)
}
const testObj = {
    name: 'mzh',
    testFn(age) {
        console.log(`${this.name}已经${age}岁`);
    }
}
const testObj2 = {
    name: 'lll'
}
testObj.testFn.mzh_apply(testObj2, [22])
*/

// !bind
/*
Function.prototype.mzh_bind = function (obj, ...args) {
    obj = obj || window
    const fn = Symbol()
    obj[fn] = this
    const _this = this
    const res = function (...innerArgs) {
        console.log(this, _this)
        if (this instanceof _this) {
            this[fn] = _this
            this[fn](...[...args, ...innerArgs])
            delete this[fn]
        } else {
            obj[fn](...[...args, ...innerArgs])
            delete obj[fn]
        }
    }
    res.prototype = Object.create(this.prototype)
    return res
}
*/

// !slice
/*
String.prototype.mzh_slice = function (start = 0, end) {
    start = start < 0 ? this.length + start : start
    end = !end && end !== 0 ? this.length : end
    if (start >= end) return ''
    let str = ''
    for (let i = start; i < end; i++) {
        str += this[i]
    }
    return str
}
const str = 'mazhonghao'
console.log(str.mzh_slice(2));
console.log(str.mzh_slice(-2));
console.log(str.mzh_slice(-9, 10));
console.log(str.mzh_slice(5, 1));
*/

// !substr
/*
String.prototype.mzh_subStr = function (start = 0, length) {
    if (length < 0) return ''
    start = start < 0 ? this.length + start : start
    length = (!length && length !== 0) || length > this.length - start ? this.length : start - length
    let str = ''
    for (let i = start; i < length; i++) {
        str += this[i]
    }
    return str
}
const str = 'mazhonghao'
console.log(str.mzh_subStr(3));
console.log(str.mzh_subStr(3, 3));
console.log(str.mzh_subStr(3, 300));
*/

**// !substring**
/*
String.prototype.mzh_substring = function (start = 0, end) {
    start = start < 0 ? this.length + start : start
    end = !end && end !== 0 ? this.length : end
    if (start >= end) [start, end] = [end, start]
    let str = ''
    for (let i = start; i < end; i++) {
        str += this[i]
    }
    return str
}
const str = 'mazhonghao '
console.log(str.mzh_substring(2));
console.log(str.mzh_substring(-2));
console.log(str.mzh_substring(-9, 10));
console.log(str.mzh_substring(5, 1));
*/

// !all
/*
function all(promises) {
    const result = []
    let count = 0
    return new MyPromise((resolve, reject) => {
        const addData = (index, value) => {
            result[index] = value
            count++
            if (count === promises.length) resolve(result)
        }
        promises.forEach((promise, index) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData(index, res)
                }, err => reject(err))

            } else {
                addData(index, promise)
            }
        })
    })
}
*/

// !race
/*
function race(promises){
    return new MyPromise((resolve,reject)=>{
        promises.forEach(promise => {
            if(promise instanceof MyPromise){
                promise.then(res => {
                    resolve(res)
                },err => {
                    reject(err)
                })
            }else{
                resolve(promise)
            }
        });
    })
}
*/

// !allSecttled
/*
function allSecttled(promises) {
    return new Promise((resolve, reject) => {
        const res = []
        let count = 0
        const addData = (status, value, i) => {
            res[i] = {
                status, value
            }
            count++
            if (count === promises.length) {
                resolve(res)
            }
        }
        promises.forEach((promise, i) => {
            if (promise instanceof MyPromise) {
                promise.then(res => {
                    addData('fulfilled', res, i)
                }, err = {
                    addData('rejected', err, i)
                })
            } else {
                addData('fulfilled', promise, i)
            }
        });
    })
}
*/

// !any
/*
function any(promises) {
    return new Promise((resolve, reject) => {
        let count = 0
        promises.forEach((promise) => {
            promise.then(val => {
                resolve(val)
            }, err => {
                count++
                if (count === promises.length) {
                    reject(new AggregateError('all promises were rejected'))
                }
            })
        });
    })
}
*/

// !finally
/*
Promise.prototype.mzh_finally = function (callback) {
    return this.then(res => {
        callback()
        return res
    }, err => {
        callback()
        throw err
    })
}
*/

**// ! 手写promise**

```
/*
自定义Promise函数模块：IIFE
 */
(function(window){
    const PENDING = 'pending';
    const RESOVLED = 'resolved';
    const REJECTED = 'rejected';
    //Promise构造函数
    //executor执行器函数
     function Promise(executor){
         let that = this;
         this.status = PENDING;   //状态未变之前都是pending
         this.data = undefined;     //未定义的数据
         this.callbacks = [];       //每个元素的结构：onResolved(){},onRejected(){}
         //执行器函数，会立即执行
         //两个改变promise状态的函数
         function resolve(value){
             if(that.status!==PENDING) return
             //调用resolve后，需要将状态改变成为resolved
             that.status = RESOVLED;
             //保存data数据
             that.data= value;
             //如果有未执行的callback，则立即异步执行onResolved,是包含两个回调的对象
             if(that.callbacks.length>0){
                 setTimeout(() => {
                    that.callbacks.forEach(element => {
                        element.onResolved(value)
                    });
                 });
             }
         }
         function reject(reason) {
            if(that.status!==PENDING) return
              //调用reject后，需要将状态改变成为rejected
              that.status = REJECTED;
              //保存data数据
              that.data= reason;
              //如果有未执行的callback，则立即异步执行onRejected,是包含两个回调的对象
              if(that.callbacks.length>0){
                  setTimeout(() => {
                    that.callbacks.forEach(element => {
                         element.onResolved(reason)
                     });
                  });
              }
         }
         //传入的参数为两个函数
         //除了resolve和reject,还有可能自己抛出异常，会失败，此时需要一个try catch
         try {
            executor(resolve,reject)
         } catch (error) {
             reject(error);
         }
     }
     /* 
     //.then接收成功失败的回调
     返回新的Promise
      */
     Promise.prototype.then = function(onResolved,onRejected){
         const that = this;
         // 指定回调函数的默认值(必须是函数)
         onResolved = typeof onResolved === 'function'?onResolved:value =>value  //继续向下传递
         onRejected = typeof onRejected ==='function'? onRejected:reason =>{throw reason}  //抛出异常
         return new Promise((resolve,reject) =>{
            function handle(callback){
                try {
                    const result = onResolved(that.data)
                    if(result instanceof Promise){
                        result.then(resolve,reject
                            // value =>{
                            //     resolve(value)
                            // },
                            // reason=>{
                            //     reject(reason)
                            // }
                        )
                    }
                } catch (error) {
                    reject(error);
                }
            }

            if(this.status ===PENDING){
            //假设当前状态还是pending,将回调保存下来
            this.callbacks.push({
                onResolved(value){
                    handle(onResolved)
                },
                onRejected(reason){
                    handle(onRejected)
                }
            })
            }else if(this.status ===RESOVLED){
                setTimeout(() => {
                //  如果回调是promise,return的promise结果就是这个promise结果
                handle(onResolved)
                });
            }else{
                //如果前面的promise返回的是失败的回调
                setTimeout(() => {
                    handle(onRejected)
                    });
            }
         })
     }
     /*
     接收失败的回调
     返回新的promise
      */
    Promise.prototype.catch = function(onRejected){
        return this.then(undefined,onRejected)
    }
    /*
    promise函数对象的resolve方法
     */
    Promise.resolve = function(value){
        return new Promise((resolve,reject) =>{
            if(value instanceof Promise){
                value.then(resolve,reject)
            }else{
                resolve(value);
            }
        })
    }
    /*
    promise函数对象的reject方法
     */
    Promise.reject = function(reason){
        return new Promise((resolve,reject) =>{
            reject(reason)
    })
    }
     //all接收数组
    Promise.all = function(promises){
        const values = [];
        const resolvedCount = 0;
        return new Promise((resolve,reject)=>{
             //遍历promise获取每个promise的结果
            promises.forEach((p,index) =>{
                Promise.resolve(p).then(
                     //成功的时候需要放入数组中
                    value => {
                         resolvedCount++;
                         values[index] = value;
                         if(resolvedCount == promises.length){
                             resolve(values);
                         }
                    },
                    reason =>{
                        //只要一个失败了，return的promise就失败
                        reject(reason)
                    }
                )
            })
        })
    }
     //race接收数组
    Promise.race = function(promise){
        //返回一个pomise
        return new Promise((resolve,reject) =>{
            Promise.resolve(p).then(
                //一旦有成功，return成功
                value =>{
                    resolve(value);
                },
                //一旦有失败，return失败
                reason =>{
                    reject(reason)
                }
            )
        })
    }

    // promise的resolveDelay，rejectDelay
/* promise函数对象的resolveDelay方法
*/ 
Promise.resolveDelay = function(value,time){
    return new Promise((resolve,reject) =>{
        setTimeout(() => {
         if(value instanceof Promise){
             value.then(resolve,reject)
         }else{
             resolve(value);
         }
        }, time);
    })
 }
 /*
 promise函数对象的rejectDelay方法
 */
 Promise.rejectDelay = function(reason,time){
    return new Promise((resolve,reject) =>{
        setTimeout(() => {
         reject(reason)
        }, time);
 })
 }
})(window)
```

**// !手写Promise**

```
/*
自定义Promise函数模块：IIFE
 */
(function(window){
    const PENDING = 'pending';
    const RESOVLED = 'resolved';
    const REJECTED = 'rejected';

    class Promise {
        constructor(executor){
        let that = this;
         this.status = PENDING;   //状态未变之前都是pending
         this.data = undefined;     //未定义的数据
         this.callbacks = [];       //每个元素的结构：onResolved(){},onRejected(){}
         //执行器函数，会立即执行
         //两个改变promise状态的函数
         function resolve(value){
             if(that.status!==PENDING) return
             //调用resolve后，需要将状态改变成为resolved
             that.status = RESOVLED;
             //保存data数据
             that.data= value;
             //如果有未执行的callback，则立即异步执行onResolved,是包含两个回调的对象
             if(that.callbacks.length>0){
                 setTimeout(() => {
                    that.callbacks.forEach(element => {
                        element.onResolved(value)
                    });
                 });
             }
         }
         function reject(reason) {
            if(that.status!==PENDING) return
              //调用reject后，需要将状态改变成为rejected
              that.status = REJECTED;
              //保存data数据
              that.data= reason;
              //如果有未执行的callback，则立即异步执行onRejected,是包含两个回调的对象
              if(that.callbacks.length>0){
                  setTimeout(() => {
                    that.callbacks.forEach(element => {
                         element.onResolved(reason)
                     });
                  });
              }
         }
         //传入的参数为两个函数
         //除了resolve和reject,还有可能自己抛出异常，会失败，此时需要一个try catch
         try {
            executor(resolve,reject)
         } catch (error) {
             reject(error);
         }
        }
             /* 
     //.then接收成功失败的回调
     返回新的Promise
      */
     then (onResolved,onRejected){
        const that = this;
        // 指定回调函数的默认值(必须是函数)
        onResolved = typeof onResolved === 'function'?onResolved:value =>value  //继续向下传递
        onRejected = typeof onRejected ==='function'? onRejected:reason =>{throw reason}  //抛出异常
        return new Promise((resolve,reject) =>{
           if(this.status ===PENDING){
           //假设当前状态还是pending,将回调保存下来
           this.callbacks.push({
               onResolved(value){
                   onResolved(that.data);
                   try {
                       const result = onResolved(that.data)
                       if(result instanceof Promise){
                           result.then(resolve,reject
                               // value =>{
                               //     resolve(value)
                               // },
                               // reason=>{
                               //     reject(reason)
                               // }
                           )
                       }
                   } catch (error) {
                       resolve(error);
                   }
               },
               onRejected(reason){
                   onRejected(that.data);
                   try {
                       const result = onRejected(that.data)
                       if(result instanceof Promise){
                           result.then(resolve,reject
                               // value =>{
                               //     resolve(value)
                               // },
                               // reason=>{
                               //     reject(reason)
                               // }
                           )
                       }
                   } catch (error) {
                       reject(error);
                   }
               }
           })
           }else if(this.status ===RESOVLED){
               setTimeout(() => {
               //  如果回调是promise,return的promise结果就是这个promise结果
               try {
                   const result = onResolved(that.data)
                   if(result instanceof Promise){
                       result.then(resolve,reject
                           // value =>{
                           //     resolve(value)
                           // },
                           // reason=>{
                           //     reject(reason)
                           // }
                       )
                   }else{//返回的不是promise，返回promise为成功，value就是返回值
                       resolve(result)
                   }
               } catch (error) {
                   reject(error);
               }
               });
           }else{
               //如果前面的promise返回的是失败的回调
               setTimeout(() => {
                   //  如果回调是promise,return的promise结果就是这个promise结果
                   try {
                       const result = onRejected(that.data)
                       if(result instanceof Promise){
                           result.then(resolve,reject
                               // value =>{
                               //     resolve(value)
                               // },
                               // reason=>{
                               //     reject(reason)
                               // }
                           )
                       }
                   } catch (error) {
                       try {
                   const result = onResolved(that.data)
                   if(result instanceof Promise){
                       result.then(resolve,reject
                           // value =>{
                           //     resolve(value)
                           // },
                           // reason=>{
                           //     reject(reason)
                           // }
                       )
                   }
               } catch (error) {
                   reject(error);
               }
                   }
                   });
           }
        })
    }
    /*
    接收失败的回调
    返回新的promise
     */
   catch (onRejected){
       return this.then(undefined,onRejected)
   }
   /*
   promise函数对象的resolve方法
    */
   static resolve(value){
       return new Promise((resolve,reject) =>{
           if(value instanceof Promise){
               value.then(resolve,reject)
           }else{
               resolve(value);
           }
       })
   }
   /*
   promise函数对象的reject方法
    */
   static reject(reason){
       return new Promise((resolve,reject) =>{
           reject(reason)
   })
   }
    //all接收数组
   static all(promises){
       const values = [];
       const resolvedCount = 0;
       return new Promise((resolve,reject)=>{
            //遍历promise获取每个promise的结果
           promises.forEach((p,index) =>{
               Promise.resolve(p).then(
                    //成功的时候需要放入数组中
                   value => {
                        resolvedCount++;
                        values[index] = value;
                        if(resolvedCount == promises.length){
                            resolve(values);
                        }
                   },
                   reason =>{
                       //只要一个失败了，return的promise就失败
                       reject(reason)
                   }
               )
           })
       })
   }
    //race接收数组
   static race (promise){
       //返回一个pomise
       return new Promise((resolve,reject) =>{
           Promise.resolve(p).then(
               //一旦有成功，return成功
               value =>{
                   resolve(value);
               },
               //一旦有失败，return失败
               reason =>{
                   reject(reason)
               }
           )
       })
   }

   // promise的resolveDelay，rejectDelay
/* promise函数对象的resolveDelay方法
*/ 
static resolveDelay (value,time){
   return new Promise((resolve,reject) =>{
       setTimeout(() => {
        if(value instanceof Promise){
            value.then(resolve,reject)
        }else{
            resolve(value);
        }
       }, time);
   })
}
/*
promise函数对象的rejectDelay方法
*/
static rejectDelay (reason,time){
   return new Promise((resolve,reject) =>{
       setTimeout(() => {
        reject(reason)
       }, time);
})
}
    }})(window)

```

